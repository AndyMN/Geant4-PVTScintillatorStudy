#include "ScintillatorAnalysisManager.h"


#include "G4PhysicalConstants.hh"

#include "TCanvas.h"
#include "TStyle.h"
#include "TGraph.h"
#include "TMultiGraph.h"
#include "TLegend.h"

#include <iostream>
#include <algorithm>
#include <map>
#include <set>


ScintillatorAnalysisManager::ScintillatorAnalysisManager(FileParser& MyFileParser){

	NumEvents = MyFileParser.NumEvents();

	StoppingPowerAnalysis = MyFileParser.AnalysisMap("StoppingPower");
	SecondaryParticlesAnalysis = MyFileParser.AnalysisMap("SecondaryParticles");
	LandauDistributionAnalysis = MyFileParser.AnalysisMap("LandauDistribution");
	PhotonWavelengthsAnalysis = MyFileParser.AnalysisMap("PhotonWavelengths");
	OptPhotonAmountEAnalysis = MyFileParser.AnalysisMap("OptPhotonAmount");
	OptPhotonAmountdEAnalysis = MyFileParser.AnalysisMap("OptPhotonAmountdE");
	OptPhotonTimeAnalysis = MyFileParser.AnalysisMap("OptPhotonTimeAnalysis");
	OptProcessesdEAnalysis = MyFileParser.AnalysisMap("OptProcessesdE");
	OptProcessesEAnalysis = MyFileParser.AnalysisMap("OptProcessesE");
	OptParentNamedEAnalysis = MyFileParser.AnalysisMap("OptParentNamedE");
	OptParentNameEAnalysis = MyFileParser.AnalysisMap("OptParentNameE");


}

ScintillatorAnalysisManager::~ScintillatorAnalysisManager(){
}


void ScintillatorAnalysisManager::EnergyContainerReset(){
	SecondaryParticlesMap.clear(); // Secondary Analysis
	dEdr_values.clear(); // Landau Distribution
	PhotonWavelengthsMap.clear(); // Opt Photon Wavelengths
	OptPhotonTimeMap.clear(); // Opt Photon Time Analysis
}

void ScintillatorAnalysisManager::SetPrimaryName(std::string PrimaryName){
	ParticleName = PrimaryName;
}

void ScintillatorAnalysisManager::SetParticleEnergyStringSave(std::string ParticleEnergyStringSave){
	_ParticleEnergyStringSave = ParticleEnergyStringSave;
}

void ScintillatorAnalysisManager::SetParticleEnergyStringTitle(std::string ParticleEnergyStringTitle){
	_ParticleEnergyStringTitle = ParticleEnergyStringTitle;
}

void ScintillatorAnalysisManager::SetScintillatorThickness(int ScintillatorThicknessy){
	ScintillatorThickness = ScintillatorThicknessy;
}


void ScintillatorAnalysisManager::DepEkinFill(double Ekin, double EDeposit){
	double DepositedE = correct_round(EDeposit, 2);
	std::cout << "Ekin: " << Ekin << " DepE: " << DepositedE << std::endl;
	std::map<double, double>::iterator depekinit = DepEkin.find(Ekin);
	if (depekinit == DepEkin.end()){
		DepEkin.insert(std::pair<double, double>(Ekin, DepositedE));
	}else{
		depekinit->second = depekinit->second + DepositedE;
	}

}


void ScintillatorAnalysisManager::OptParentNameDepEFill(double EDeposit, std::map<int, std::string> ParticleNameTrackID, std::map<int, int> OptPhotonsParentID){
	if (OptParentNamedEAnalysis[ParticleName]){
		std::map<std::string, int> OptPhotonsParentName;
		std::map<std::string, int>::iterator parentnameit;

		// Fill map with Parent Name and Amount Opt Photons generated by it
		std::map<int, int>::iterator parentidit;
		for (parentidit = OptPhotonsParentID.begin(); parentidit != OptPhotonsParentID.end(); ++parentidit){
			int NumOptPhotons = parentidit->second;
			std::string CreatorName = ParticleNameTrackID[parentidit->first];
			parentnameit =  OptPhotonsParentName.find(CreatorName);
			if (parentnameit == OptPhotonsParentName.end()){
				OptPhotonsParentName.insert(std::pair<std::string, int>(CreatorName, NumOptPhotons));
			}else{
				parentnameit->second = parentnameit->second + NumOptPhotons;
			}
		}

		double DepE = correct_round(EDeposit, 2);
		std::map<double, std::map<std::string, int>>::iterator optparentit;
		optparentit = OptParentNamedE.find(DepE);
		if (optparentit == OptParentNamedE.end()){
			OptParentNamedE.insert(std::pair<double, std::map<std::string, int>>(DepE, OptPhotonsParentName));
		}else{
			for (parentnameit = OptPhotonsParentName.begin(); parentnameit != OptPhotonsParentName.end(); ++parentnameit){
				optparentit->second[parentnameit->first] = optparentit->second[parentnameit->first] + parentnameit->second;
			}
		}
	}
}

void ScintillatorAnalysisManager::OptParentNameEFill(double Ekin, std::map<int, std::string> ParticleNameTrackID, std::map<int, int> OptPhotonsParentID){
	if (OptParentNameEAnalysis[ParticleName]){
		std::map<std::string, int> OptPhotonsParentName;
		std::map<std::string, int>::iterator parentnameit;

		// Fill map with Parent Name and Amount Opt Photons generated by it
		std::map<int, int>::iterator parentidit;
		for (parentidit = OptPhotonsParentID.begin(); parentidit != OptPhotonsParentID.end(); ++parentidit){
			int NumOptPhotons = parentidit->second;
			std::string CreatorName = ParticleNameTrackID[parentidit->first];
			parentnameit =  OptPhotonsParentName.find(CreatorName);
			if (parentnameit == OptPhotonsParentName.end()){
				OptPhotonsParentName.insert(std::pair<std::string, int>(CreatorName, NumOptPhotons));
			}else{
				parentnameit->second = parentnameit->second + NumOptPhotons;
			}
		}

		std::map<double, std::map<std::string, int>>::iterator optparentit;
		optparentit = OptParentNameEkin.find(Ekin);
		if (optparentit == OptParentNameEkin.end()){
			OptParentNameEkin.insert(std::pair<double, std::map<std::string, int>>(Ekin, OptPhotonsParentName));
		}else{
			for (parentnameit = OptPhotonsParentName.begin(); parentnameit != OptPhotonsParentName.end(); ++parentnameit){
				optparentit->second[parentnameit->first] = optparentit->second[parentnameit->first] + parentnameit->second;
			}
		}

	}
}

void ScintillatorAnalysisManager::OptProcessesEFill(double Ekin, std::map<std::string, int> OptPhotonProcesses){
	if (OptProcessesEAnalysis[ParticleName]){
		std::map<double, std::map<std::string, int>>::iterator process_it;
		process_it = OptProcessesEkin.find(Ekin);
		if (process_it == OptProcessesEkin.end()){
			OptProcessesEkin.insert(std::pair<double, std::map<std::string, int>>(Ekin, OptPhotonProcesses));
		}else{
			process_it->second["Cerenkov"] = process_it->second["Cerenkov"] + OptPhotonProcesses["Cerenkov"];
			process_it->second["Scintillation"] = process_it->second["Scintillation"] + OptPhotonProcesses["Scintillation"];
		}
	}
}

void ScintillatorAnalysisManager::IntProcessesEFill(double Ekin, std::map<std::string, int> InteractionProcesses){
	if (StoppingPowerAnalysis[ParticleName]){
		std::map<double, std::map<std::string, int>>::iterator intprocessekin_it;
		intprocessekin_it = InteractionProcessesEkin.find(Ekin);
		if (intprocessekin_it == InteractionProcessesEkin.end()){
			InteractionProcessesEkin.insert(std::pair<double, std::map<std::string, int>>(Ekin, InteractionProcesses));
		}else{
			std::map<std::string, int>::iterator intprocess_it;
			for (intprocess_it = InteractionProcesses.begin(); intprocess_it != InteractionProcesses.end(); ++intprocess_it){

				intprocessekin_it->second[intprocess_it->first] = intprocessekin_it->second[intprocess_it->first] + intprocess_it->second;
			}
		}
	}
}

void ScintillatorAnalysisManager::OptProcessesDepEFill(double EDeposit, std::map<std::string, int> OptPhotonProcesses){
	if (OptProcessesdEAnalysis[ParticleName]){
		double TotalEDep = EDeposit;
		TotalEDep = correct_round(TotalEDep, 2);
		std::map<double, std::map<std::string, int>>::iterator process_it;
		process_it = OptProcessesdE.find(TotalEDep);
		if (process_it == OptProcessesdE.end()){
			OptProcessesdE.insert(std::pair<double, std::map<std::string, int>>(TotalEDep, OptPhotonProcesses));
		}else{
			process_it->second["Cerenkov"] = process_it->second["Cerenkov"] + OptPhotonProcesses["Cerenkov"];
			process_it->second["Scintillation"] = process_it->second["Scintillation"] + OptPhotonProcesses["Scintillation"];
		}
	}
}

void ScintillatorAnalysisManager::OptPhotonAmountEFill(double Ekin, int NumOptPhotons){
	if (OptPhotonAmountEAnalysis[ParticleName]){
		std::map<double, int>::iterator optamount_it;
		optamount_it = OptPhotonAmountMap.find(Ekin);
		if (optamount_it == OptPhotonAmountMap.end()){
			OptPhotonAmountMap.insert(std::pair<double, int>(Ekin, NumOptPhotons));
		}else{
			if (NumOptPhotons > 0){
				optamount_it->second = optamount_it->second + NumOptPhotons;
			}
		}
	}
}



void ScintillatorAnalysisManager::OptPhotonAmountDepEFill(double TotalEnergyDeposit, int NumOptPhotons){

	if (OptPhotonAmountdEAnalysis[ParticleName]){
		double TotalEDep = TotalEnergyDeposit;
		TotalEDep = correct_round(TotalEDep, 2);
		if (TotalEDep > 0){
			std::map<double, int>::iterator optdE_it;
			//std::cout << "dE: " << DepEnergy << " Nopt: " << num_optphotons << std::endl;
			optdE_it = OptPhotonAmountdEMap.find(TotalEDep);
			if (optdE_it == OptPhotonAmountdEMap.end()){
				OptPhotonAmountdEMap.insert(std::pair<double, int>(TotalEDep, NumOptPhotons));
				OptPhotonAmountdEDivisionMap.insert(std::pair<double, int>(TotalEDep, 1));
			}else{
				if (NumOptPhotons > 0){
					optdE_it->second = optdE_it->second + NumOptPhotons;
					std::map<double, int>::iterator optdEdiv_it;
					optdEdiv_it = OptPhotonAmountdEDivisionMap.find(TotalEDep);
					optdEdiv_it->second = optdEdiv_it->second + 1;
				}
			}
		}
	}
}


void ScintillatorAnalysisManager::OptPhotonTimeFill(double OptPhotonGlobalTime){
	if (OptPhotonTimeAnalysis[ParticleName]){
		// Round to 1 decimal 0.1 ns
		double DeltaGlobalTime = OptPhotonGlobalTime;
		DeltaGlobalTime = correct_round(DeltaGlobalTime);
		if (DeltaGlobalTime > 0){
			std::map<double, int>::iterator optphoton_it;
			optphoton_it = OptPhotonTimeMap.find(DeltaGlobalTime);
			if (optphoton_it == OptPhotonTimeMap.end()){
				OptPhotonTimeMap.insert(std::pair<double, int>(DeltaGlobalTime, 1));
			}else{
				optphoton_it->second = optphoton_it->second + 1;
			}
		}
	}
}

void ScintillatorAnalysisManager::OptPhotonWavelengthsFill(double Etot){
	if (PhotonWavelengthsAnalysis[ParticleName]){
		double PhotonWavelength = (h_Planck * c_light) / Etot;
		PhotonWavelength *= 1000000; // Wavelength in nm
		PhotonWavelength = correct_round(PhotonWavelength);
		std::map<double, int>::iterator photon_it;
		photon_it = PhotonWavelengthsMap.find(PhotonWavelength); // Now we can collect photons at 1 decimal precision
		if (photon_it == PhotonWavelengthsMap.end()){
			PhotonWavelengthsMap.insert(std::pair<double, int>(PhotonWavelength, 1));
		}else{
			photon_it->second = photon_it->second + 1;
		}
	}
}

void ScintillatorAnalysisManager::LandauDistributionFill(double dE, double dr){
	if (LandauDistributionAnalysis[ParticleName]){
		if (dE <= 0 || dr <= 0){
			return;
		}

		double dEdr = (dE / dr) * 10; // MeV / cm
		// Round to 1 decimal
		dEdr = correct_round(dEdr, 2);
		std::cout << "dE/dr: " << dEdr << std::endl;
		if (dEdr > 1000){
			std::cout << "HERE--------------------------------------------------------------" << std::endl;
		}
		if (dEdr > 0){
			dEdr_values.push_back(dEdr);
		}
	}
}

void ScintillatorAnalysisManager::SecondaryParticlesFill(std::string SecondaryParticleName){
	if (SecondaryParticlesAnalysis[ParticleName]){
		std::map<std::string, int>::iterator it;
		it = SecondaryParticlesMap.find(SecondaryParticleName);
		if (it == SecondaryParticlesMap.end()){
			SecondaryParticlesMap.insert(std::pair<std::string, int>(SecondaryParticleName, 1));
		}else{
			it->second = it->second + 1;
		}
	}
}

void ScintillatorAnalysisManager::StoppingPowerFill(double Ekin, double dE, double dr){
	if (StoppingPowerAnalysis[ParticleName]){
		std::cout << "EKinf: " << Ekin << std::endl;
		std::cout << "dEf: " << dE << std::endl;
		std::cout << "drf: " << dr << std::endl;
		if (dE < 0 || dr <= 0){
			return;
		}
		double dEdr = (dE / dr) * 10; // MeV / cm
		if (dE == 0){
			dEdr = 0.000001;
		}
		if (dEdr > 10000){
			std::cout << "THIS ONE IS CRAAAZYYY" << std::endl;
			std::cout << "EKinf: " << Ekin << std::endl;
			std::cout << "dEf: " << dE << std::endl;
			std::cout << "drf: " << dr << std::endl;
			return;
		}
		std::map<double, double>::iterator stop_it;
		stop_it = StoppingPowerMap.find(Ekin);
		if (stop_it == StoppingPowerMap.end()){
			StoppingPowerMap.insert(std::pair<double, double>(Ekin, dEdr));
			DivisorMap.insert(std::pair<double, int>(Ekin, 1));
		}else{
			stop_it->second = stop_it->second + dEdr;
			std::map<double, int>::iterator div_it;
			div_it = DivisorMap.find(Ekin);
			div_it->second = div_it->second + 1;
		}
	}
}

void ScintillatorAnalysisManager::OptPhotonWavelengthsDraw(){
// Optical PHoton Wavelengths Finalization
	if (PhotonWavelengthsMap.size() > 0){
		std::string CanvasName = "Optical Photon Wavelengths for " + ParticleName + " with energy " + _ParticleEnergyStringTitle + " in " + ScintillatorMaterial;
		double x_max = PhotonWavelengthsMap.rbegin()->first;
		double x_min = PhotonWavelengthsMap.begin()->first;
		int num_bins = PhotonWavelengthsMap.size() * 2;
		TH1F* PhotonWavelengthsHist = new TH1F(CanvasName.c_str(), CanvasName.c_str(), num_bins, x_min, x_max);
		std::map<double, int>::iterator photon_it;
		for (photon_it = PhotonWavelengthsMap.begin(); photon_it != PhotonWavelengthsMap.end(); ++photon_it){
			PhotonWavelengthsHist->Fill(photon_it->first, photon_it->second);
		}
		PhotonWavelengthsHist->SetYTitle("N");
		PhotonWavelengthsHist->SetXTitle("Wavelength (nm)");
		PhotonWavelengthsHist->SetMarkerStyle(7);
		/*if (SaveHistograms){
			TFile* OutFile = new TFile(HistogramFileName.c_str(), "UPDATE");
			PhotonWavelengthsHist->Write();
			OutFile->Close();
		}*/
		std::string SaveName = ParticleName + "PE" + _ParticleEnergyStringSave + "PhotonWavelengths.png";
		DrawHistogram(PhotonWavelengthsHist, CanvasName, SaveName, "P");

	}

}


void ScintillatorAnalysisManager::StoppingPowerDraw(){
	// Stopping Power Analysis Finalization
	if (StoppingPowerMap.size() > 0 ){
		std::string	CanvasName = "Stopping Power for " + ParticleName + " in " + ScintillatorMaterial + " with thickness " + std::to_string(ScintillatorThickness) + " mm";
		std::map<double, int>::iterator div_it;
		std::map<double, double>::iterator stop_it;
		for (stop_it = StoppingPowerMap.begin(); stop_it != StoppingPowerMap.end(); ++stop_it){
				div_it = DivisorMap.find(stop_it->first);
				stop_it->second = stop_it->second / div_it->second;
		}
		double x_max = StoppingPowerMap.rbegin()->first;
		double x_min = StoppingPowerMap.begin()->first;
		int num_bins = StoppingPowerMap.size() * 10000;
		TH1F* StoppingPowerHist = new TH1F(CanvasName.c_str(), CanvasName.c_str(), num_bins, x_min, x_max);
		for (stop_it = StoppingPowerMap.begin(); stop_it != StoppingPowerMap.end(); ++stop_it){
			StoppingPowerHist->Fill(stop_it->first, stop_it->second);
		}
		StoppingPowerHist->SetXTitle("Ekin (MeV) ");
		StoppingPowerHist->SetYTitle("dE/dx (MeV / cm)");
		StoppingPowerHist->SetMarkerStyle(7);
		StoppingPowerHist->Sumw2();

		std::string SaveName = ParticleName + "ST" + std::to_string(ScintillatorThickness) +"StoppingPower.png";
		DrawHistogram(StoppingPowerHist, CanvasName, SaveName, "E", true);
	}
}


void ScintillatorAnalysisManager::SecondaryParticlesDraw(){
	if (SecondaryParticlesMap.size() > 0){
		std::string CanvasName = "Secondary Particles for " + ParticleName + " with energy " + _ParticleEnergyStringTitle;
		TH1F* SecondaryParticlesHist = new TH1F(CanvasName.c_str(), CanvasName.c_str(), SecondaryParticlesMap.size(), 0, SecondaryParticlesMap.size());
		std::map<std::string, int>::iterator it;
		for (it = SecondaryParticlesMap.begin(); it != SecondaryParticlesMap.end(); ++it){
			SecondaryParticlesHist->Fill((it->first).c_str(), it->second);
		}
		SecondaryParticlesHist->SetYTitle("N");
		SecondaryParticlesHist->SetMinimum(0);
		/*if (SaveHistograms){
			TFile* OutFile = new TFile(HistogramFileName.c_str(), "UPDATE");
			SecondaryParticlesHist->Write();
			OutFile->Close();
		}*/
		std::string SaveName = ParticleName + "PE" + _ParticleEnergyStringSave + "SecondaryParticles.png";
		DrawHistogram(SecondaryParticlesHist, CanvasName, SaveName);

	}

}

void ScintillatorAnalysisManager::LandauDistributionDraw(){
	if (dEdr_values.size() > 0){
		std::string CanvasName = "dE / dx for " + ParticleName + " with energy " + _ParticleEnergyStringTitle + " in " + ScintillatorMaterial;
		double x_max = *std::max_element(dEdr_values.begin(), dEdr_values.end());
		TH1F* LandauDistributionHist = new TH1F(CanvasName.c_str(), CanvasName.c_str(), 10000, 0, x_max);
		for (int i = 0; i < dEdr_values.size(); i++){
			LandauDistributionHist->Fill(dEdr_values[i]);
		}
		LandauDistributionHist->SetXTitle("dE / dx (MeV / cm)");
		LandauDistributionHist->SetYTitle("N");
		/*if (SaveHistograms){
			TFile* OutFile = new TFile(HistogramFileName.c_str(), "UPDATE");
			LandauDistributionHist->Write();
			OutFile->Close();
		}*/
		std::string SaveName = ParticleName + "PE" + _ParticleEnergyStringSave + "LandauDistribution.png";
		DrawHistogram(LandauDistributionHist, CanvasName, SaveName);

	}

}


void ScintillatorAnalysisManager::OptPhotonTimeDraw(){
	if (OptPhotonTimeMap.size() > 0){
		std::string CanvasName = "Optical Photon Time spectrum for " + ParticleName + " with energy " + _ParticleEnergyStringTitle + " in " + ScintillatorMaterial;
		double x_max = OptPhotonTimeMap.rbegin()->first;
		int num_bins = OptPhotonTimeMap.size() * 2;
		TH1F* OptPhotonTimeHist = new TH1F(CanvasName.c_str(), CanvasName.c_str(), num_bins, 0.0, x_max);
		std::map<double, int>::iterator optphoton_it;
		for (optphoton_it = OptPhotonTimeMap.begin(); optphoton_it != OptPhotonTimeMap.end(); ++optphoton_it){
			OptPhotonTimeHist->Fill(optphoton_it->first, optphoton_it->second);
		}
		OptPhotonTimeHist->SetYTitle("N");
		OptPhotonTimeHist->SetXTitle("Time (ns)");
		OptPhotonTimeHist->SetMarkerStyle(7);
		/*if (SaveHistograms){
			TFile* OutFile = new TFile(HistogramFileName.c_str(), "UPDATE");
			OptPhotonTimeHist->Write();
			OutFile->Close();
		}*/
		std::string SaveName = ParticleName + "PE" + _ParticleEnergyStringSave + "OptPhotonTime.png";
		DrawHistogram(OptPhotonTimeHist, CanvasName, SaveName, "P");

	}

}

void ScintillatorAnalysisManager::OptPhotonAmountDepEDraw(){

	if (OptPhotonAmountdEMap.size() > 0){
		std::string CanvasName = "N Opt Photons for Deposited Energy for " + ParticleName + " in " + ScintillatorMaterial + " with thickness " + std::to_string(ScintillatorThickness) + " mm";
		double x_max = OptPhotonAmountdEMap.rbegin()->first;
		double x_min = OptPhotonAmountdEMap.begin()->first;
		int num_bins = OptPhotonAmountdEMap.size() * 10000;
		std::cout << "Amount of Values: " << OptPhotonAmountdEMap.size() << std::endl;
		TH1F* OptPhotonAmountdEHist = new TH1F(CanvasName.c_str(), CanvasName.c_str(), num_bins, x_min, x_max);
		std::map<double, int>::iterator optdE_it;
		std::map<double, int>::iterator optdEdiv_it;
		for (optdE_it = OptPhotonAmountdEMap.begin(); optdE_it != OptPhotonAmountdEMap.end(); ++optdE_it){
			optdEdiv_it = OptPhotonAmountdEDivisionMap.find(optdE_it->first);
			//std::cout << "dE: " << std::to_string(optdE_it->first) << " NOpt: " << optdE_it->second <<  " NTimes: " << optdEdiv_it->second << std::endl;

			optdE_it->second = optdE_it->second / optdEdiv_it->second;
		}
		OptPhotonAmountdEHist->Sumw2();
		for (optdE_it = OptPhotonAmountdEMap.begin(); optdE_it != OptPhotonAmountdEMap.end(); ++optdE_it){
			OptPhotonAmountdEHist->Fill(optdE_it->first, optdE_it->second);
		}
		OptPhotonAmountdEHist->SetXTitle("Deposited Energy (MeV)");
		OptPhotonAmountdEHist->SetYTitle("N");
		OptPhotonAmountdEHist->SetMarkerStyle(7);
		//OptPhotonAmountdEHist->Sumw2();
		/*if (SaveHistograms){
			TFile* Outfile = new TFile(HistogramFileName.c_str(), "UPDATE");
			OptPhotonAmountdEHist->Write();
			Outfile->Close();
		}*/
		std::string SaveName = ParticleName + "ST" + std::to_string(ScintillatorThickness) +"OptPhotonsDepEnergy.png";
		DrawHistogram(OptPhotonAmountdEHist, CanvasName, SaveName, "E", true);
	}
}

void ScintillatorAnalysisManager::OptProcessesDepEDraw(){
	if (OptProcessesdE.size() > 0){
		int NItems = OptProcessesdE.size();
		double DepE[NItems];
		double ScintillationFrac[NItems];
		double CerenkovFrac[NItems];

		std::map<double, std::map<std::string, int>>::iterator process_it;
		int item = 0;
		for (process_it = OptProcessesdE.begin(); process_it != OptProcessesdE.end(); ++process_it){
			DepE[item] = process_it->first;
			int TotalOptPhotons = process_it->second["Scintillation"] * 100 + process_it->second["Cerenkov"];
			ScintillationFrac[item] = (double)process_it->second["Scintillation"] * 100 / TotalOptPhotons;
			CerenkovFrac[item] = (double)process_it->second["Cerenkov"] / TotalOptPhotons;
			//std::cout << "DepE: " << DepE[item] << " Scintillation: " << ScintillationFrac[item] << " Cerenkov: " << CerenkovFrac[item] << std::endl;
			item++;
		}
		std::string CanvasName = "Opt Photons per process for Deposited Energy for " + ParticleName + " in " + ScintillatorMaterial + " with thickness " + std::to_string(ScintillatorThickness) + " mm";

		TCanvas* Canvas = new TCanvas(CanvasName.c_str(), CanvasName.c_str());
		TGraph* ScintGraph = new TGraph(NItems, DepE, ScintillationFrac);
		ScintGraph->SetTitle(CanvasName.c_str());
		ScintGraph->SetMarkerStyle(2);
		ScintGraph->SetMarkerColor(2);
		ScintGraph->Draw("AP");
		ScintGraph->GetXaxis()->SetTitle("Deposited Energy (MeV)");
		ScintGraph->GetYaxis()->SetTitle("N_process / N_total");
		ScintGraph->GetYaxis()->SetRangeUser(0.0, 1.4);
		ScintGraph->Draw("AP");
		Canvas->Update();

		TGraph* CerenGraph = new TGraph(NItems, DepE, CerenkovFrac);
		CerenGraph->SetMarkerStyle(5);
		CerenGraph->SetMarkerColor(4);
		CerenGraph->Draw("SAMEP");
		Canvas->Update();

		TLegend* Legend = new TLegend(0.1, 0.7, 0.3, 0.9);
		Legend->AddEntry(ScintGraph, "Scintillation", "P");
		Legend->AddEntry(CerenGraph, "Cerenkov", "P");
		Legend->Draw();

		std::string SaveName = ParticleName + "ST" + std::to_string(ScintillatorThickness) + "OptPhotonsProcessDepE.png";
		Canvas->SaveAs(SaveName.c_str());
		Canvas->Close();

	}
}

void ScintillatorAnalysisManager::IntProcessesDraw(){
	if (InteractionProcessesEkin.size() > 0){
		int NItems = InteractionProcessesEkin.size();
		double Ekin[NItems];

		std::map<std::string, std::vector<double>> ProcessesFractions;
		std::map<std::string, std::vector<double>>::iterator processfrac_it;

		std::map<double, std::map<std::string, int>>::iterator intprocessekin_it;

		// GET ALL PROCESSES POSSIBLE
		std::set<std::string> Processes;
		for (intprocessekin_it = InteractionProcessesEkin.begin(); intprocessekin_it != InteractionProcessesEkin.end(); ++intprocessekin_it){
			std::map<std::string, int>::iterator intprocess_it;
			std::map<std::string, int> InteractionProcesses = intprocessekin_it->second;
			for (intprocess_it = InteractionProcesses.begin(); intprocess_it != InteractionProcesses.end(); ++intprocess_it){
				Processes.insert(intprocess_it->first);
			}
		}

		// Initialize an empty vector with length of amount of energy points for every process
		std::set<std::string>::iterator process_it;
		for (process_it = Processes.begin(); process_it != Processes.end(); ++process_it){
			std::cout << *process_it << std::endl;
			ProcessesFractions.insert(std::pair<std::string, std::vector<double>>(*process_it, std::vector<double>(NItems, 0)));
		}

		int item = 0;
		if (Processes.size() > 0){
			for (intprocessekin_it = InteractionProcessesEkin.begin(); intprocessekin_it != InteractionProcessesEkin.end(); ++intprocessekin_it){
				Ekin[item] = intprocessekin_it->first;

				// Get total number of times a process happened and put it in corresponding vector
				int total_processes = 0;
				for (process_it = Processes.begin(); process_it != Processes.end(); ++process_it){
					ProcessesFractions[*process_it][item] = (double)intprocessekin_it->second[*process_it];
					total_processes += intprocessekin_it->second[*process_it];
				}
				// Divide every total number of times a process happened by total number of processes to get fraction
				for (process_it = Processes.begin(); process_it != Processes.end(); ++process_it){
					if (total_processes > 0){
						ProcessesFractions[*process_it][item] /= total_processes;
					}
				}
				item++;
			}


			std::string CanvasName = "Interaction processes per Begin Energy for " + ParticleName + " in " + ScintillatorMaterial + " with thickness " + std::to_string(ScintillatorThickness) + " mm";

			TCanvas* Canvas = new TCanvas(CanvasName.c_str(), CanvasName.c_str());
			TLegend* Legend = new TLegend(0.1, 0.7, 0.3, 0.9);
			TGraph* ProcessGraphs[Processes.size()];
			TMultiGraph* MultiGraph = new TMultiGraph();
			int graph = 0;
			for (processfrac_it = ProcessesFractions.begin(); processfrac_it != ProcessesFractions.end(); ++processfrac_it){
				double fractions[NItems];
				std::copy(processfrac_it->second.begin(), processfrac_it->second.end(), fractions);

				ProcessGraphs[graph] = new TGraph(NItems, Ekin, fractions);
				ProcessGraphs[graph]->SetTitle(CanvasName.c_str());
				ProcessGraphs[graph]->SetMarkerStyle(2);
				ProcessGraphs[graph]->SetMarkerColor(graph + 1);
				Legend->AddEntry(ProcessGraphs[graph], processfrac_it->first.c_str(), "P");
				MultiGraph->Add(ProcessGraphs[graph]);
				graph += 1;

			}
			MultiGraph->Draw("AP");
			MultiGraph->SetTitle(CanvasName.c_str());
			MultiGraph->GetXaxis()->SetTitle("Kinetic Energy (MeV)");
			MultiGraph->GetYaxis()->SetTitle("N_process / N_total");
			MultiGraph->GetYaxis()->SetRangeUser(0.0, 1.4);
			MultiGraph->Draw("AP");
			Legend->Draw();
			std::string SaveName = ParticleName + "ST" + std::to_string(ScintillatorThickness) + "SecondaryParticlesProcessEkin.png";
			Canvas->Update();
			Canvas->SaveAs(SaveName.c_str());
			Canvas->Close();

		}
	}
}

void ScintillatorAnalysisManager::OptProcessesEDraw(){
	if (OptProcessesEkin.size() > 0){
		int NItems = OptProcessesEkin.size();
		double Ekin[NItems];
		double ScintillationFrac[NItems];
		double CerenkovFrac[NItems];

		std::map<double, std::map<std::string, int>>::iterator process_it;
		int item = 0;
		for (process_it = OptProcessesEkin.begin(); process_it != OptProcessesEkin.end(); ++process_it){
			Ekin[item] = process_it->first;
			int TotalOptPhotons = process_it->second["Scintillation"] * 100 + process_it->second["Cerenkov"];
			ScintillationFrac[item] = (double)process_it->second["Scintillation"] * 100 / TotalOptPhotons;
			CerenkovFrac[item] = (double)process_it->second["Cerenkov"] / TotalOptPhotons;
			//std::cout << "DepE: " << DepE[item] << " Scintillation: " << ScintillationFrac[item] << " Cerenkov: " << CerenkovFrac[item] << std::endl;
			item++;
		}
		std::string CanvasName = "Opt Photons per process per Begin Energy for " + ParticleName + " in " + ScintillatorMaterial + " with thickness " + std::to_string(ScintillatorThickness) + " mm";

		TCanvas* Canvas = new TCanvas(CanvasName.c_str(), CanvasName.c_str());
		TGraph* ScintGraph = new TGraph(NItems, Ekin, ScintillationFrac);
		ScintGraph->SetTitle(CanvasName.c_str());
		ScintGraph->SetMarkerStyle(2);
		ScintGraph->SetMarkerColor(2);
		ScintGraph->Draw("AP");
		ScintGraph->GetXaxis()->SetTitle("Kinetic Energy (MeV)");
		ScintGraph->GetYaxis()->SetTitle("N_process / N_total");
		ScintGraph->GetYaxis()->SetRangeUser(0.0, 1.4);
		ScintGraph->Draw("AP");
		Canvas->Update();

		TGraph* CerenGraph = new TGraph(NItems, Ekin, CerenkovFrac);
		CerenGraph->SetMarkerStyle(5);
		CerenGraph->SetMarkerColor(4);
		CerenGraph->Draw("SAMEP");
		Canvas->Update();

		TLegend* Legend = new TLegend(0.1, 0.7, 0.3, 0.9);
		Legend->AddEntry(ScintGraph, "Scintillation", "P");
		Legend->AddEntry(CerenGraph, "Cerenkov", "P");
		Legend->Draw();

		std::string SaveName = ParticleName + "ST" + std::to_string(ScintillatorThickness) + "OptPhotonsProcessEkin.png";
		Canvas->SaveAs(SaveName.c_str());
		Canvas->Close();

	}
}

void ScintillatorAnalysisManager::OptParentNameDepEDraw(){
	if (OptParentNamedE.size() > 0){
		int NItems = OptParentNamedE.size();
		double DepE[NItems];
		std::map<double, int> TotalOptPhotons;


		// Fill set with all possible Parent Paricle Names
		std::set<std::string> ParentNames;
		std::map<double, std::map<std::string, int>>::iterator optparentit;
		for (optparentit = OptParentNamedE.begin(); optparentit != OptParentNamedE.end(); ++optparentit){
			double depositedE = optparentit->first;
			int numOptPhotons = 0;
			std::map<std::string, int>::iterator parentit;
			for (parentit = (optparentit->second).begin(); parentit != (optparentit->second).end(); ++parentit){
				ParentNames.insert(parentit->first);
				numOptPhotons += parentit->second;
			}
			TotalOptPhotons.insert(std::pair<double, int>(depositedE, numOptPhotons * 100));
		}

		std::string CanvasName = "Opt Photons per Parent Particle per Dep. E for " + ParticleName + " in " + ScintillatorMaterial + " with thickness " + std::to_string(ScintillatorThickness) + " mm";

		TCanvas* Canvas = new TCanvas(CanvasName.c_str(), CanvasName.c_str());
		TLegend* Legend = new TLegend(0.1, 0.7, 0.3, 0.9);
		TGraph* graphs[ParentNames.size()];
		TMultiGraph* mgraphs = new TMultiGraph();

		std::set<std::string>::iterator parentnamesit;
		int graph_index = 0;
		for (parentnamesit = ParentNames.begin(); parentnamesit != ParentNames.end(); ++parentnamesit){
			//std::cout << *parentnamesit << std::endl;
			graph_index++;
			double OptPhotons[NItems];
			int index = 0;
			for (optparentit = OptParentNamedE.begin(); optparentit != OptParentNamedE.end(); ++optparentit){
				OptPhotons[index] = (double)optparentit->second[*parentnamesit] / TotalOptPhotons[optparentit->first];
				DepE[index] = optparentit->first;
				index++;
			}

			graphs[graph_index - 1] = new TGraph(NItems, DepE, OptPhotons);
			graphs[graph_index - 1]->SetMarkerStyle(2);
			graphs[graph_index - 1]->SetMarkerColor(graph_index);

			mgraphs->Add(graphs[graph_index - 1]);

			Legend->AddEntry(graphs[graph_index - 1], (*parentnamesit).c_str(), "P");

		}
		mgraphs->Draw("AP");
		mgraphs->SetTitle(CanvasName.c_str());
		mgraphs->GetXaxis()->SetTitle("Deposited Energy (MeV)");
		mgraphs->GetYaxis()->SetTitle("N_parent / N_total");
		mgraphs->GetYaxis()->SetRangeUser(0.0, 1.4);
		mgraphs->Draw("AP");


		Legend->Draw();

		std::string SaveName = ParticleName + "ST" + std::to_string(ScintillatorThickness) + "OptPhotonsParentDepE.png";
		Canvas->SaveAs(SaveName.c_str());
		Canvas->Close();



	}
}

void ScintillatorAnalysisManager::OptParentNameEDraw(){
	if (OptParentNameEkin.size() > 0){
		int NItems = OptParentNameEkin.size();
		double Ekin[NItems];
		std::map<double, int> TotalOptPhotons;


		// Fill set with all possible Parent Paricle Names
		std::set<std::string> ParentNames;
		std::map<double, std::map<std::string, int>>::iterator optparentit;
		for (optparentit = OptParentNameEkin.begin(); optparentit != OptParentNameEkin.end(); ++optparentit){
			double kineticE = optparentit->first;
			int numOptPhotons = 0;
			std::map<std::string, int>::iterator parentit;
			for (parentit = (optparentit->second).begin(); parentit != (optparentit->second).end(); ++parentit){
				ParentNames.insert(parentit->first);
				numOptPhotons += parentit->second;
			}
			TotalOptPhotons.insert(std::pair<double, int>(kineticE, numOptPhotons));
		}

		std::string CanvasName = "Opt Photons per Parent Particle per Start Ekin for " + ParticleName + " in " + ScintillatorMaterial + " with thickness " + std::to_string(ScintillatorThickness) + " mm";

		TCanvas* Canvas = new TCanvas(CanvasName.c_str(), CanvasName.c_str());
		TLegend* Legend = new TLegend(0.1, 0.7, 0.3, 0.9);
		TGraph* graphs[ParentNames.size()];
		TMultiGraph* mgraphs = new TMultiGraph();

		std::set<std::string>::iterator parentnamesit;
		int graph_index = 0;
		for (parentnamesit = ParentNames.begin(); parentnamesit != ParentNames.end(); ++parentnamesit){
			//std::cout << *parentnamesit << std::endl;
			graph_index++;
			double OptPhotons[NItems];
			int index = 0;
			for (optparentit = OptParentNameEkin.begin(); optparentit != OptParentNameEkin.end(); ++optparentit){
				OptPhotons[index] = (double)optparentit->second[*parentnamesit] / TotalOptPhotons[optparentit->first];
				Ekin[index] = optparentit->first;
				index++;
			}

			graphs[graph_index - 1] = new TGraph(NItems, Ekin, OptPhotons);
			graphs[graph_index - 1]->SetMarkerStyle(2);
			graphs[graph_index - 1]->SetMarkerColor(graph_index);

			mgraphs->Add(graphs[graph_index - 1]);

			Legend->AddEntry(graphs[graph_index - 1], (*parentnamesit).c_str(), "P");

		}
		mgraphs->Draw("AP");
		mgraphs->SetTitle(CanvasName.c_str());
		mgraphs->GetXaxis()->SetTitle("Kinetic Energy (MeV)");
		mgraphs->GetYaxis()->SetTitle("N_parent / N_total");
		mgraphs->GetYaxis()->SetRangeUser(0.0, 1.4);
		mgraphs->Draw("AP");


		Legend->Draw();

		std::string SaveName = ParticleName + "ST" + std::to_string(ScintillatorThickness) + "OptPhotonsParentEkin.png";
		Canvas->SaveAs(SaveName.c_str());
		Canvas->Close();

	}


}



void ScintillatorAnalysisManager::OptPhotonAmountEDraw(){
	if (OptPhotonAmountMap.size() > 0){
		std::string	CanvasName = "N Opt Photons for " + ParticleName + " in " + ScintillatorMaterial + " with thickness " + std::to_string(ScintillatorThickness) + " mm";
		double x_max = OptPhotonAmountMap.rbegin()->first;
		double x_min = OptPhotonAmountMap.begin()->first;
		int num_bins = OptPhotonAmountMap.size() * 10000;
		TH1F* OptPhotonAmountHist = new TH1F(CanvasName.c_str(), CanvasName.c_str(), num_bins, x_min, x_max);
		OptPhotonAmountHist->Sumw2();
		std::map<double, int>::iterator optamount_it;
		for (optamount_it = OptPhotonAmountMap.begin(); optamount_it != OptPhotonAmountMap.end(); ++optamount_it){
			OptPhotonAmountHist->Fill(optamount_it->first, optamount_it->second / NumEvents);
		}
		OptPhotonAmountHist->SetXTitle("Ekin (MeV)");
		OptPhotonAmountHist->SetYTitle("N");
		OptPhotonAmountHist->SetMarkerStyle(7);
		/*if (SaveHistograms){
			TFile* Outfile = new TFile(HistogramFileName.c_str(), "UPDATE");
			OptPhotonAmountHist->Write();
			Outfile->Close();
		}*/
		std::string SaveName = ParticleName + "ST" + std::to_string(ScintillatorThickness) + "AmountOptPhotons.png";
		DrawHistogram(OptPhotonAmountHist, CanvasName, SaveName, "E", true);

	}
}

void ScintillatorAnalysisManager::DepEkinDraw(){
	if (DepEkin.size() > 0){
		std::string CanvasName = "Deposited Energy for Start Ekin " + ParticleName + " in " + ScintillatorMaterial + " with thickness " + std::to_string(ScintillatorThickness) + " mm";
		double x_max = DepEkin.rbegin()->first;
		double x_min = DepEkin.begin()->first;
		int num_bins = DepEkin.size() * 10000;
		TH1F* DepEkinHist = new TH1F(CanvasName.c_str(), CanvasName.c_str(), num_bins, x_min, x_max);
		std::map<double, double>::iterator depekinit;
		for (depekinit = DepEkin.begin(); depekinit != DepEkin.end(); ++depekinit){
			DepEkinHist->Fill(depekinit->first, depekinit->second / NumEvents);
		}
		DepEkinHist->SetXTitle("Ekin (MeV)");
		DepEkinHist->SetYTitle("Deposited Energy (MeV)");
		DepEkinHist->Sumw2();
		DepEkinHist->SetMarkerStyle(7);

		std::string SaveName = ParticleName + "ST" + std::to_string(ScintillatorThickness) + "DepEkin.png";
		DrawHistogram(DepEkinHist, CanvasName, SaveName, "E", true);
	}
}


void ScintillatorAnalysisManager::DrawHistogram(TH1F* Histogram, std::string CanvasName, std::string SaveName, std::string DrawOptions, bool LogCheck){

		TCanvas* Canvas = new TCanvas(CanvasName.c_str(), CanvasName.c_str());
		Canvas->cd();
		if (LogCheck){
			double x_max = Histogram->GetXaxis()->GetXmax();
			double x_min = Histogram->GetXaxis()->GetXmin();
			if (x_max - x_min >= 100){
				Canvas->SetLogx();
			}
		}
		gStyle->SetOptStat(0);
		Histogram->Draw(DrawOptions.c_str());
		Canvas->Update();

		Canvas->SaveAs(SaveName.c_str());
		Canvas->Close();

}

double ScintillatorAnalysisManager::correct_round(double NumToRound, int SignificantDigits){
	double RoundedNum = NumToRound;
	std::string NumString = std::to_string(NumToRound);

	int period_pos = NumString.find(".");

	if (period_pos >= 2 || NumString[period_pos - 1] != '0'){
		// A number like 15.46 will become 15.5
		RoundedNum *= 10;
		int int_RoundedNum = (int)(RoundedNum + 0.5);
		RoundedNum = (double)int_RoundedNum / 10.0;
	}else{
		// A number like 0.00567 will become 0.0057
		std::string decimalstring = NumString.substr(period_pos + 1);
		int first_nonzero = decimalstring.find_first_not_of("0");
		RoundedNum *= pow(10.0, first_nonzero + SignificantDigits);
		int int_RoundedNum = (int)(RoundedNum + 0.5);
		RoundedNum = int_RoundedNum / (pow(10.0, first_nonzero + SignificantDigits));
	}

	return RoundedNum;
}
